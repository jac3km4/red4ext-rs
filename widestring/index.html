<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A wide string library for converting to and from wide string variants."><title>widestring - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="widestring" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../widestring/index.html">widestring</a><span class="version">1.1.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">widestring</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/widestring/lib.rs.html#1-749">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A wide string library for converting to and from wide string variants.</p>
<p>This library provides multiple types of wide strings, each corresponding to a string types in
the Rust standard library. <a href="utfstring/struct.Utf16String.html" title="struct widestring::utfstring::Utf16String"><code>Utf16String</code></a> and <a href="utfstring/struct.Utf32String.html" title="struct widestring::utfstring::Utf32String"><code>Utf32String</code></a> are analogous to the standard
<a href="https://doc.rust-lang.org/1.80.1/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> type, providing a similar interface, and are always encoded as valid UTF-16 and
UTF-32, respectively. They are the only type in this library that can losslessly and infallibly
convert to and from <a href="https://doc.rust-lang.org/1.80.1/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>, and are the easiest type to work with. They are not designed for
working with FFI, but do support efficient conversions from the FFI types.</p>
<p><a href="ustring/struct.U16String.html" title="struct widestring::ustring::U16String"><code>U16String</code></a> and <a href="ustring/struct.U32String.html" title="struct widestring::ustring::U32String"><code>U32String</code></a>, on the other hand, are similar to (but not the same as),
<a href="https://doc.rust-lang.org/1.80.1/std/ffi/os_str/struct.OsString.html" title="struct std::ffi::os_str::OsString"><code>OsString</code></a>, and are designed around working with FFI. Unlike the UTF variants, these strings
do not have a defined encoding, and can work with any wide character strings, regardless of
the encoding. They can be converted to and from <a href="https://doc.rust-lang.org/1.80.1/std/ffi/os_str/struct.OsString.html" title="struct std::ffi::os_str::OsString"><code>OsString</code></a> (but may require an encoding
conversion depending on the platform), although that string type is an OS-specified
encoding, so take special care.</p>
<p><a href="ustring/struct.U16String.html" title="struct widestring::ustring::U16String"><code>U16String</code></a> and <a href="ustring/struct.U32String.html" title="struct widestring::ustring::U32String"><code>U32String</code></a> also allow access and mutation that relies on the user
to enforce any constraints on the data. Some methods do assume a UTF encoding, but do so in a
way that handles malformed encoding data. For FFI, use <a href="ustring/struct.U16String.html" title="struct widestring::ustring::U16String"><code>U16String</code></a> or <a href="ustring/struct.U32String.html" title="struct widestring::ustring::U32String"><code>U32String</code></a> when you
simply need to pass-through string data, or when you’re not dealing with a nul-terminated data.</p>
<p>Finally, <a href="ucstring/struct.U16CString.html" title="struct widestring::ucstring::U16CString"><code>U16CString</code></a> and <a href="ucstring/struct.U32CString.html" title="struct widestring::ucstring::U32CString"><code>U32CString</code></a> are wide version of the standard <a href="https://doc.rust-lang.org/1.80.1/alloc/ffi/c_str/struct.CString.html" title="struct alloc::ffi::c_str::CString"><code>CString</code></a> type.
Like <a href="ustring/struct.U16String.html" title="struct widestring::ustring::U16String"><code>U16String</code></a> and <a href="ustring/struct.U32String.html" title="struct widestring::ustring::U32String"><code>U32String</code></a>, they do not have defined encoding, but are designed to
work with FFI, particularly C-style nul-terminated wide string data. These C-style strings are
always terminated in a nul value, and are guaranteed to contain no interior nul values (unless
unchecked methods are used). Again, these types may contain ill-formed encoding data, and
methods handle it appropriately. Use <a href="ucstring/struct.U16CString.html" title="struct widestring::ucstring::U16CString"><code>U16CString</code></a> or <a href="ucstring/struct.U32CString.html" title="struct widestring::ucstring::U32CString"><code>U32CString</code></a> anytime you must properly
handle nul values for when dealing with wide string C FFI.</p>
<p>Like the standard Rust string types, each wide string type has its corresponding wide string
slice type, as shown in the following table:</p>
<div><table><thead><tr><th>String Type</th><th>Slice Type</th></tr></thead><tbody>
<tr><td><a href="utfstring/struct.Utf16String.html" title="struct widestring::utfstring::Utf16String"><code>Utf16String</code></a></td><td><a href="utfstr/struct.Utf16Str.html" title="struct widestring::utfstr::Utf16Str"><code>Utf16Str</code></a></td></tr>
<tr><td><a href="utfstring/struct.Utf32String.html" title="struct widestring::utfstring::Utf32String"><code>Utf32String</code></a></td><td><a href="utfstr/struct.Utf32Str.html" title="struct widestring::utfstr::Utf32Str"><code>Utf32Str</code></a></td></tr>
<tr><td><a href="ustring/struct.U16String.html" title="struct widestring::ustring::U16String"><code>U16String</code></a></td><td><a href="ustr/struct.U16Str.html" title="struct widestring::ustr::U16Str"><code>U16Str</code></a></td></tr>
<tr><td><a href="ustring/struct.U32String.html" title="struct widestring::ustring::U32String"><code>U32String</code></a></td><td><a href="ustr/struct.U32Str.html" title="struct widestring::ustr::U32Str"><code>U32Str</code></a></td></tr>
<tr><td><a href="ucstring/struct.U16CString.html" title="struct widestring::ucstring::U16CString"><code>U16CString</code></a></td><td><a href="ucstr/struct.U16CStr.html" title="struct widestring::ucstr::U16CStr"><code>U16CStr</code></a></td></tr>
<tr><td><a href="ucstring/struct.U32CString.html" title="struct widestring::ucstring::U32CString"><code>U32CString</code></a></td><td><a href="ucstr/struct.U32CStr.html" title="struct widestring::ucstr::U32CStr"><code>U32CStr</code></a></td></tr>
</tbody></table>
</div>
<p>All the string types in this library can be converted between string types of the same bit
width, as well as appropriate standard Rust types, but be lossy and/or require knowledge of the
underlying encoding. The UTF strings additionally can be converted between the two sizes of
string, re-encoding the strings.</p>
<h2 id="wide-string-literals"><a class="doc-anchor" href="#wide-string-literals">§</a>Wide string literals</h2>
<p>Macros are provided for each wide string slice type that convert standard Rust <a href="https://doc.rust-lang.org/1.80.1/std/primitive.str.html" title="primitive str"><code>str</code></a> literals
into UTF-16 or UTF-32 encoded versions of the slice type at <em>compile time</em>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>widestring::u16str;
<span class="kw">let </span>hello = <span class="macro">u16str!</span>(<span class="string">"Hello, world!"</span>); <span class="comment">// `hello` will be a &amp;U16Str value</span></code></pre></div>
<p>These can be used anywhere a <code>const</code> function can be used, and provide a convenient method of
specifying wide string literals instead of coding values by hand. The resulting string slices
are always valid UTF encoding, and the <a href="macro.u16cstr.html" title="macro widestring::u16cstr"><code>u16cstr!</code></a> and <a href="macro.u32cstr.html" title="macro widestring::u32cstr"><code>u32cstr!</code></a> macros are automatically
nul-terminated.</p>
<h2 id="cargo-features"><a class="doc-anchor" href="#cargo-features">§</a>Cargo features</h2>
<p>This crate supports <code>no_std</code> when default cargo features are disabled. The <code>std</code> and <code>alloc</code>
cargo features (enabled by default) enable the owned string types: <a href="ustring/struct.U16String.html" title="struct widestring::ustring::U16String"><code>U16String</code></a>, <a href="ustring/struct.U32String.html" title="struct widestring::ustring::U32String"><code>U32String</code></a>,
<a href="ucstring/struct.U16CString.html" title="struct widestring::ucstring::U16CString"><code>U16CString</code></a>, <a href="ucstring/struct.U32CString.html" title="struct widestring::ucstring::U32CString"><code>U32CString</code></a>, <a href="utfstring/struct.Utf16String.html" title="struct widestring::utfstring::Utf16String"><code>Utf16String</code></a>, and <a href="utfstring/struct.Utf32String.html" title="struct widestring::utfstring::Utf32String"><code>Utf32String</code></a> types and their modules.
Other types such as the string slices do not require allocation and can be used in a <code>no_std</code>
environment, even without the <a href="https://doc.rust-lang.org/stable/alloc/index.html"><code>alloc</code></a>
crate.</p>
<h2 id="remarks-on-utf-16-and-utf-32"><a class="doc-anchor" href="#remarks-on-utf-16-and-utf-32">§</a>Remarks on UTF-16 and UTF-32</h2>
<p>UTF-16 encoding is a variable-length encoding. The 16-bit code units can specificy Unicode code
points either as single units or in <em>surrogate pairs</em>. Because every value might be part of a
surrogate pair, many regular string operations on UTF-16 data, including indexing, writing, or
even iterating, require considering either one or two values at a time. This library provides
safe methods for these operations when the data is known to be UTF-16, such as with
<a href="utfstring/struct.Utf16String.html" title="struct widestring::utfstring::Utf16String"><code>Utf16String</code></a>. In those cases, keep in mind that the number of elements (<code>len()</code>) of the
wide string is <em>not</em> equivalent to the number of Unicode code points in the string, but is
instead the number of code unit values.</p>
<p>For <a href="ustring/struct.U16String.html" title="struct widestring::ustring::U16String"><code>U16String</code></a> and <a href="ucstring/struct.U16CString.html" title="struct widestring::ucstring::U16CString"><code>U16CString</code></a>, which do not define an encoding, these same operations
(indexing, mutating, iterating) do <em>not</em> take into account UTF-16 encoding and may result in
sequences that are ill-formed UTF-16. Some methods are provided that do make an exception to
this and treat the strings as malformed UTF-16, which are specified in their documentation as to
how they handle the invalid data.</p>
<p>UTF-32 simply encodes Unicode code points as-is in 32-bit Unicode Scalar Values, but Unicode
character code points are reserved only for 21-bits, and UTF-16 surrogates are invalid in
UTF-32. Since UTF-32 is a fixed-width encoding, it is much easier to deal with, but equivalent
methods to the 16-bit strings are provided for compatibility.</p>
<p>All the 32-bit wide strings provide efficient methods to convert to and from sequences of
<a href="https://doc.rust-lang.org/1.80.1/std/primitive.char.html" title="primitive char"><code>char</code></a> data, as the representation of UTF-32 strings is functionally equivalent to sequences
of <a href="https://doc.rust-lang.org/1.80.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s. Keep in mind that only <a href="utfstring/struct.Utf32String.html" title="struct widestring::utfstring::Utf32String"><code>Utf32String</code></a> guaruntees this equivalence, however, since
the other strings may contain invalid values.</p>
<h2 id="ffi-with-cc-wchar_t"><a class="doc-anchor" href="#ffi-with-cc-wchar_t">§</a>FFI with C/C++ <code>wchar_t</code></h2>
<p>C/C++’s <code>wchar_t</code> (and C++’s corresponding <code>widestring</code>) varies in size depending on compiler
and platform. Typically, <code>wchar_t</code> is 16-bits on Windows and 32-bits on most Unix-based
platforms. For convenience when using <code>wchar_t</code>-based FFI’s, type aliases for the corresponding
string types are provided: <a href="ustring/type.WideString.html" title="type widestring::ustring::WideString"><code>WideString</code></a> aliases <a href="ustring/struct.U16String.html" title="struct widestring::ustring::U16String"><code>U16String</code></a> on Windows or <a href="ustring/struct.U32String.html" title="struct widestring::ustring::U32String"><code>U32String</code></a>
elsewhere, <a href="ucstring/type.WideCString.html" title="type widestring::ucstring::WideCString"><code>WideCString</code></a> aliases <a href="ucstring/struct.U16CString.html" title="struct widestring::ucstring::U16CString"><code>U16CString</code></a> or <a href="ucstring/struct.U32CString.html" title="struct widestring::ucstring::U32CString"><code>U32CString</code></a>, and <a href="utfstring/type.WideUtfString.html" title="type widestring::utfstring::WideUtfString"><code>WideUtfString</code></a>
aliases <a href="utfstring/struct.Utf16String.html" title="struct widestring::utfstring::Utf16String"><code>Utf16String</code></a> or <a href="utfstring/struct.Utf32String.html" title="struct widestring::utfstring::Utf32String"><code>Utf32String</code></a>. <a href="ustr/type.WideStr.html" title="type widestring::ustr::WideStr"><code>WideStr</code></a>, <a href="ucstr/type.WideCStr.html" title="type widestring::ucstr::WideCStr"><code>WideCStr</code></a>, and <a href="utfstr/type.WideUtfStr.html" title="type widestring::utfstr::WideUtfStr"><code>WideUtfStr</code></a> are
provided for the string slice types. The <a href="type.WideChar.html" title="type widestring::WideChar"><code>WideChar</code></a> alias is also provided, aliasing <a href="https://doc.rust-lang.org/1.80.1/std/primitive.u16.html" title="primitive u16"><code>u16</code></a>
or <a href="https://doc.rust-lang.org/1.80.1/std/primitive.u32.html" title="primitive u32"><code>u32</code></a> depending on platform.</p>
<p>When not interacting with a FFI that uses <code>wchar_t</code>, it is recommended to use the string types
directly rather than via the wide alias.</p>
<h2 id="nul-values"><a class="doc-anchor" href="#nul-values">§</a>Nul values</h2>
<p>This crate uses the term legacy ASCII term “nul” to refer to Unicode code point <code>U+0000 NULL</code>
and its associated code unit representation as zero-value bytes. This is to disambiguate this
zero value from null pointer values. C-style strings end in a nul value, while regular Rust
strings allow interior nul values and are not terminated with nul.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p>The following example uses <a href="ustring/struct.U16String.html" title="struct widestring::ustring::U16String"><code>U16String</code></a> to get Windows error messages, since <code>FormatMessageW</code>
returns a string length for us and we don’t need to pass error messages into other FFI
functions so we don’t need to worry about nul values.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>winapi::um::winbase::{FormatMessageW, LocalFree, FORMAT_MESSAGE_FROM_SYSTEM,
                          FORMAT_MESSAGE_ALLOCATE_BUFFER, FORMAT_MESSAGE_IGNORE_INSERTS};
<span class="kw">use </span>winapi::shared::ntdef::LPWSTR;
<span class="kw">use </span>winapi::shared::minwindef::HLOCAL;
<span class="kw">use </span>std::ptr;
<span class="kw">use </span>widestring::U16String;

<span class="kw">let </span>s: U16String;
<span class="kw">unsafe </span>{
    <span class="comment">// First, get a string buffer from some windows api such as FormatMessageW...
    </span><span class="kw">let </span><span class="kw-2">mut </span>buffer: LPWSTR = ptr::null_mut();
    <span class="kw">let </span>strlen = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_IGNORE_INSERTS,
                                ptr::null(),
                                error_code, <span class="comment">// error code from GetLastError()
                                </span><span class="number">0</span>,
                                (<span class="kw-2">&amp;mut </span>buffer <span class="kw">as </span><span class="kw-2">*mut </span>LPWSTR) <span class="kw">as </span>LPWSTR,
                                <span class="number">0</span>,
                                ptr::null_mut());

    <span class="comment">// Get the buffer as a wide string
    </span>s = U16String::from_ptr(buffer, strlen <span class="kw">as </span>usize);
    <span class="comment">// Since U16String creates an owned copy, it's safe to free original buffer now
    // If you didn't want an owned copy, you could use &amp;U16Str.
    </span>LocalFree(buffer <span class="kw">as </span>HLOCAL);
}
<span class="comment">// Convert to a regular Rust String and use it to your heart's desire!
</span><span class="kw">let </span>message = s.to_string_lossy();</code></pre></div>
<p>The following example is the functionally the same, only using <a href="ucstring/struct.U16CString.html" title="struct widestring::ucstring::U16CString"><code>U16CString</code></a> instead.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>winapi::um::winbase::{FormatMessageW, LocalFree, FORMAT_MESSAGE_FROM_SYSTEM,
                          FORMAT_MESSAGE_ALLOCATE_BUFFER, FORMAT_MESSAGE_IGNORE_INSERTS};
<span class="kw">use </span>winapi::shared::ntdef::LPWSTR;
<span class="kw">use </span>winapi::shared::minwindef::HLOCAL;
<span class="kw">use </span>std::ptr;
<span class="kw">use </span>widestring::U16CString;

<span class="kw">let </span>s: U16CString;
<span class="kw">unsafe </span>{
    <span class="comment">// First, get a string buffer from some windows api such as FormatMessageW...
    </span><span class="kw">let </span><span class="kw-2">mut </span>buffer: LPWSTR = ptr::null_mut();
    FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                   FORMAT_MESSAGE_ALLOCATE_BUFFER |
                   FORMAT_MESSAGE_IGNORE_INSERTS,
                   ptr::null(),
                   error_code, <span class="comment">// error code from GetLastError()
                   </span><span class="number">0</span>,
                   (<span class="kw-2">&amp;mut </span>buffer <span class="kw">as </span><span class="kw-2">*mut </span>LPWSTR) <span class="kw">as </span>LPWSTR,
                   <span class="number">0</span>,
                   ptr::null_mut());

    <span class="comment">// Get the buffer as a wide string
    </span>s = U16CString::from_ptr_str(buffer);
    <span class="comment">// Since U16CString creates an owned copy, it's safe to free original buffer now
    // If you didn't want an owned copy, you could use &amp;U16CStr.
    </span>LocalFree(buffer <span class="kw">as </span>HLOCAL);
}
<span class="comment">// Convert to a regular Rust String and use it to your heart's desire!
</span><span class="kw">let </span>message = s.to_string_lossy();</code></pre></div>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.U16CStr"><code>pub use ucstr::<a class="struct" href="ucstr/struct.U16CStr.html" title="struct widestring::ucstr::U16CStr">U16CStr</a>;</code></div></li><li><div class="item-name" id="reexport.U32CStr"><code>pub use ucstr::<a class="struct" href="ucstr/struct.U32CStr.html" title="struct widestring::ucstr::U32CStr">U32CStr</a>;</code></div></li><li><div class="item-name" id="reexport.WideCStr"><code>pub use ucstr::<a class="type" href="ucstr/type.WideCStr.html" title="type widestring::ucstr::WideCStr">WideCStr</a>;</code></div></li><li><div class="item-name" id="reexport.U16CString"><code>pub use ucstring::<a class="struct" href="ucstring/struct.U16CString.html" title="struct widestring::ucstring::U16CString">U16CString</a>;</code></div></li><li><div class="item-name" id="reexport.U32CString"><code>pub use ucstring::<a class="struct" href="ucstring/struct.U32CString.html" title="struct widestring::ucstring::U32CString">U32CString</a>;</code></div></li><li><div class="item-name" id="reexport.WideCString"><code>pub use ucstring::<a class="type" href="ucstring/type.WideCString.html" title="type widestring::ucstring::WideCString">WideCString</a>;</code></div></li><li><div class="item-name" id="reexport.U16Str"><code>pub use ustr::<a class="struct" href="ustr/struct.U16Str.html" title="struct widestring::ustr::U16Str">U16Str</a>;</code></div></li><li><div class="item-name" id="reexport.U32Str"><code>pub use ustr::<a class="struct" href="ustr/struct.U32Str.html" title="struct widestring::ustr::U32Str">U32Str</a>;</code></div></li><li><div class="item-name" id="reexport.WideStr"><code>pub use ustr::<a class="type" href="ustr/type.WideStr.html" title="type widestring::ustr::WideStr">WideStr</a>;</code></div></li><li><div class="item-name" id="reexport.U16String"><code>pub use ustring::<a class="struct" href="ustring/struct.U16String.html" title="struct widestring::ustring::U16String">U16String</a>;</code></div></li><li><div class="item-name" id="reexport.U32String"><code>pub use ustring::<a class="struct" href="ustring/struct.U32String.html" title="struct widestring::ustring::U32String">U32String</a>;</code></div></li><li><div class="item-name" id="reexport.WideString"><code>pub use ustring::<a class="type" href="ustring/type.WideString.html" title="type widestring::ustring::WideString">WideString</a>;</code></div></li><li><div class="item-name" id="reexport.Utf16Str"><code>pub use utfstr::<a class="struct" href="utfstr/struct.Utf16Str.html" title="struct widestring::utfstr::Utf16Str">Utf16Str</a>;</code></div></li><li><div class="item-name" id="reexport.Utf32Str"><code>pub use utfstr::<a class="struct" href="utfstr/struct.Utf32Str.html" title="struct widestring::utfstr::Utf32Str">Utf32Str</a>;</code></div></li><li><div class="item-name" id="reexport.WideUtfStr"><code>pub use utfstr::<a class="type" href="utfstr/type.WideUtfStr.html" title="type widestring::utfstr::WideUtfStr">WideUtfStr</a>;</code></div></li><li><div class="item-name" id="reexport.Utf16String"><code>pub use utfstring::<a class="struct" href="utfstring/struct.Utf16String.html" title="struct widestring::utfstring::Utf16String">Utf16String</a>;</code></div></li><li><div class="item-name" id="reexport.Utf32String"><code>pub use utfstring::<a class="struct" href="utfstring/struct.Utf32String.html" title="struct widestring::utfstring::Utf32String">Utf32String</a>;</code></div></li><li><div class="item-name" id="reexport.WideUtfString"><code>pub use utfstring::<a class="type" href="utfstring/type.WideUtfString.html" title="type widestring::utfstring::WideUtfString">WideUtfString</a>;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="error/index.html" title="mod widestring::error">error</a></div><div class="desc docblock-short">Errors returned by functions in this crate.</div></li><li><div class="item-name"><a class="mod" href="iter/index.html" title="mod widestring::iter">iter</a></div><div class="desc docblock-short">Iterators for encoding and decoding slices of string data.</div></li><li><div class="item-name"><a class="mod" href="ucstr/index.html" title="mod widestring::ucstr">ucstr</a></div><div class="desc docblock-short">C-style wide string slices.</div></li><li><div class="item-name"><a class="mod" href="ucstring/index.html" title="mod widestring::ucstring">ucstring</a></div><div class="desc docblock-short">C-style owned, growable wide strings.</div></li><li><div class="item-name"><a class="mod" href="ustr/index.html" title="mod widestring::ustr">ustr</a></div><div class="desc docblock-short">Wide string slices with undefined encoding.</div></li><li><div class="item-name"><a class="mod" href="ustring/index.html" title="mod widestring::ustring">ustring</a></div><div class="desc docblock-short">Owned, growable wide strings with undefined encoding.</div></li><li><div class="item-name"><a class="mod" href="utfstr/index.html" title="mod widestring::utfstr">utfstr</a></div><div class="desc docblock-short">UTF string slices.</div></li><li><div class="item-name"><a class="mod" href="utfstring/index.html" title="mod widestring::utfstring">utfstring</a></div><div class="desc docblock-short">Owned, growable UTF strings.</div></li></ul><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.include_utf16str.html" title="macro widestring::include_utf16str">include_utf16str</a></div><div class="desc docblock-short">Includes a UTF-16 encoded file as a <a href="utfstr/struct.Utf16Str.html" title="struct widestring::utfstr::Utf16Str"><code>Utf16Str</code></a>.</div></li><li><div class="item-name"><a class="macro" href="macro.u16cstr.html" title="macro widestring::u16cstr">u16cstr</a></div><div class="desc docblock-short">Converts a string literal into a <code>const</code> UTF-16 string slice of type
<a href="ucstr/struct.U16CStr.html" title="struct widestring::ucstr::U16CStr"><code>U16CStr</code></a>.</div></li><li><div class="item-name"><a class="macro" href="macro.u16str.html" title="macro widestring::u16str">u16str</a></div><div class="desc docblock-short">Converts a string literal into a <code>const</code> UTF-16 string slice of type
<a href="ustr/struct.U16Str.html" title="struct widestring::ustr::U16Str"><code>U16Str</code></a>.</div></li><li><div class="item-name"><a class="macro" href="macro.u32cstr.html" title="macro widestring::u32cstr">u32cstr</a></div><div class="desc docblock-short">Converts a string literal into a <code>const</code> UTF-32 string slice of type
<a href="ucstr/struct.U32CStr.html" title="struct widestring::ucstr::U32CStr"><code>U32CStr</code></a>.</div></li><li><div class="item-name"><a class="macro" href="macro.u32str.html" title="macro widestring::u32str">u32str</a></div><div class="desc docblock-short">Converts a string literal into a <code>const</code> UTF-32 string slice of type
<a href="ustr/struct.U32Str.html" title="struct widestring::ustr::U32Str"><code>U32Str</code></a>.</div></li><li><div class="item-name"><a class="macro" href="macro.utf16str.html" title="macro widestring::utf16str">utf16str</a></div><div class="desc docblock-short">Converts a string literal into a <code>const</code> UTF-16 string slice of type
<a href="utfstr/struct.Utf16Str.html" title="struct widestring::utfstr::Utf16Str"><code>Utf16Str</code></a>.</div></li><li><div class="item-name"><a class="macro" href="macro.utf32str.html" title="macro widestring::utf32str">utf32str</a></div><div class="desc docblock-short">Converts a string literal into a <code>const</code> UTF-32 string slice of type
<a href="utfstr/struct.Utf32Str.html" title="struct widestring::utfstr::Utf32Str"><code>Utf32Str</code></a>.</div></li><li><div class="item-name"><a class="macro" href="macro.widecstr.html" title="macro widestring::widecstr">widecstr</a></div><div class="desc docblock-short">Alias for <a href="macro.u16cstr.html" title="macro widestring::u16cstr"><code>u16cstr</code></a> or <a href="macro.u32cstr.html" title="macro widestring::u32cstr"><code>u32cstr</code></a> macros depending on platform. Intended to be used when
using <a href="ucstr/type.WideCStr.html" title="type widestring::ucstr::WideCStr"><code>WideCStr</code></a> type alias.</div></li><li><div class="item-name"><a class="macro" href="macro.widestr.html" title="macro widestring::widestr">widestr</a></div><div class="desc docblock-short">Alias for <a href="macro.u16str.html" title="macro widestring::u16str"><code>u16str</code></a> or <a href="macro.u32str.html" title="macro widestring::u32str"><code>u32str</code></a> macros depending on platform. Intended to be used when using
<a href="ustr/type.WideStr.html" title="type widestring::ustr::WideStr"><code>WideStr</code></a> type alias.</div></li><li><div class="item-name"><a class="macro" href="macro.wideutfstr.html" title="macro widestring::wideutfstr">wideutfstr</a></div><div class="desc docblock-short">Alias for <a href="macro.utf16str.html" title="macro widestring::utf16str"><code>utf16str</code></a> or <a href="macro.utf32str.html" title="macro widestring::utf32str"><code>utf32str</code></a> macros depending on platform. Intended to be used when
using <a href="utfstr/type.WideUtfStr.html" title="type widestring::utfstr::WideUtfStr"><code>WideUtfStr</code></a> type alias.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.decode_utf16.html" title="fn widestring::decode_utf16">decode_utf16</a></div><div class="desc docblock-short">Creates an iterator over the UTF-16 encoded code points in <code>iter</code>, returning unpaired surrogates
as <code>Err</code>s.</div></li><li><div class="item-name"><a class="fn" href="fn.decode_utf16_lossy.html" title="fn widestring::decode_utf16_lossy">decode_utf16_lossy</a></div><div class="desc docblock-short">Creates a lossy decoder iterator over the possibly ill-formed UTF-16 encoded code points in
<code>iter</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.decode_utf32.html" title="fn widestring::decode_utf32">decode_utf32</a></div><div class="desc docblock-short">Creates a decoder iterator over UTF-32 encoded code points in <code>iter</code>, returning invalid values
as <code>Err</code>s.</div></li><li><div class="item-name"><a class="fn" href="fn.decode_utf32_lossy.html" title="fn widestring::decode_utf32_lossy">decode_utf32_lossy</a></div><div class="desc docblock-short">Creates a lossy decoder iterator over the possibly ill-formed UTF-32 encoded code points in
<code>iter</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.encode_utf8.html" title="fn widestring::encode_utf8">encode_utf8</a></div><div class="desc docblock-short">Creates an iterator that encodes an iterator over <a href="https://doc.rust-lang.org/1.80.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s into UTF-8 bytes.</div></li><li><div class="item-name"><a class="fn" href="fn.encode_utf16.html" title="fn widestring::encode_utf16">encode_utf16</a></div><div class="desc docblock-short">Creates an iterator that encodes an iterator over <a href="https://doc.rust-lang.org/1.80.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s into UTF-16 <a href="https://doc.rust-lang.org/1.80.1/std/primitive.u16.html" title="primitive u16"><code>u16</code></a> code units.</div></li><li><div class="item-name"><a class="fn" href="fn.encode_utf32.html" title="fn widestring::encode_utf32">encode_utf32</a></div><div class="desc docblock-short">Creates an iterator that encodes an iterator over <a href="https://doc.rust-lang.org/1.80.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s into UTF-32 <a href="https://doc.rust-lang.org/1.80.1/std/primitive.u32.html" title="primitive u32"><code>u32</code></a> values.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.WideChar.html" title="type widestring::WideChar">WideChar</a></div><div class="desc docblock-short">Alias for <a href="https://doc.rust-lang.org/1.80.1/std/primitive.u16.html" title="primitive u16"><code>u16</code></a> or <a href="https://doc.rust-lang.org/1.80.1/std/primitive.u32.html" title="primitive u32"><code>u32</code></a> depending on platform. Intended to match typical C <code>wchar_t</code> size
on platform.</div></li></ul></section></div></main></body></html>